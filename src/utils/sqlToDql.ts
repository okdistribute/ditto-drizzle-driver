/**
 * Translates SQL queries generated by Drizzle to DQL (Ditto Query Language)
 * This is a simple implementation that handles basic CRUD operations.
 * More complex SQL features may need additional handling.
 */

export interface DQLQuery {
  query: string;
  args?: Record<string, any>;
}

/**
 * Convert SQL query and parameters to DQL
 */
export function sqlToDql(sql: string, params: any[]): DQLQuery {
  // Normalize the SQL
  const normalizedSql = sql.trim();
  
  // Parse the SQL statement type
  const upperSql = normalizedSql.toUpperCase();
  
  if (upperSql.startsWith('SELECT')) {
    return translateSelect(normalizedSql, params);
  } else if (upperSql.startsWith('INSERT')) {
    return translateInsert(normalizedSql, params);
  } else if (upperSql.startsWith('UPDATE')) {
    return translateUpdate(normalizedSql, params);
  } else if (upperSql.startsWith('DELETE')) {
    return translateDelete(normalizedSql, params);
  } else {
    throw new Error(`Unsupported SQL statement: ${normalizedSql.substring(0, 50)}`);
  }
}

/**
 * Translate SELECT statement
 * SQL: SELECT * FROM users WHERE name = ? AND age > ?
 * DQL: SELECT * FROM users WHERE name = :arg1 AND age > :arg2
 * 
 * SQL: SELECT COUNT(*), SUM(age) FROM users GROUP BY status
 * DQL: SELECT COUNT(*), SUM(age) FROM users GROUP BY status
 */
function translateSelect(sql: string, params: any[]): DQLQuery {
  let dql = sql;
  const args: Record<string, any> = {};
  
  // Replace ? placeholders with named parameters
  let paramIndex = 0;
  dql = dql.replace(/\?/g, () => {
    const paramName = `arg${paramIndex + 1}`;
    args[paramName] = params[paramIndex];
    paramIndex++;
    return `:${paramName}`;
  });
  
  // Handle SQLite-specific syntax that might need conversion
  // For example, converting "users"."name" to users.name
  dql = dql.replace(/"([^"]+)"\."([^"]+)"/g, '$1.$2');
  dql = dql.replace(/"([^"]+)"/g, '$1');
  
  // Handle aggregate functions - these are supported in DQL
  // COUNT, SUM, AVG, MIN, MAX are all supported
  // COUNT(*) is supported directly
  // DISTINCT is also supported: COUNT(DISTINCT field)
  
  // Handle column aliases with AS
  // SQL: SELECT name AS user_name
  // DQL: SELECT name AS user_name (supported)
  
  // Handle GROUP BY - supported in DQL
  // SQL: GROUP BY status, age
  // DQL: GROUP BY status, age (supported)
  
  // Handle HAVING - supported in DQL
  // SQL: HAVING COUNT(*) > 5
  // DQL: HAVING COUNT(*) > 5 (supported)
  
  // Map 'id' to '_id' for DQL compatibility
  // Use word boundaries to avoid replacing 'id' in words like 'MID' or 'valid'
  dql = dql.replace(/\bid\b/gi, (match, offset, str) => {
    // Check if this is part of 'MID' function
    if (offset > 0 && str[offset - 1].toUpperCase() === 'M') {
      return match;
    }
    return '_id';
  });
  
  return { query: dql, args: Object.keys(args).length > 0 ? args : undefined };
}

/**
 * Translate INSERT statement
 * SQL: INSERT INTO users (name, age) VALUES (?, ?), (?, ?)
 * DQL: INSERT INTO users DOCUMENTS (:doc1), (:doc2)
 */
function translateInsert(sql: string, params: any[]): DQLQuery {
  // Match the table name and columns
  const tableMatch = sql.match(/INSERT\s+INTO\s+"?(\w+)"?\s*\(([^)]+)\)/i);
  
  if (!tableMatch) {
    throw new Error(`Unable to parse INSERT statement: ${sql}`);
  }
  
  const tableName = tableMatch[1];
  const columns = tableMatch[2].split(',').map(col => col.trim().replace(/"/g, ''));
  
  // Count how many value sets we have by counting placeholders
  const valuesMatch = sql.match(/VALUES\s*(.*)/i);
  if (!valuesMatch) {
    throw new Error(`Unable to parse VALUES clause: ${sql}`);
  }
  
  // Count the number of value sets by counting opening parentheses after VALUES
  const valuesClause = valuesMatch[1];
  const valueSets = valuesClause.match(/\([^)]+\)/g);
  
  if (!valueSets) {
    throw new Error(`Unable to parse value sets: ${sql}`);
  }
  
  const numRows = valueSets.length;
  const numColumns = columns.length;
  
  // Build document objects for each row
  const args: Record<string, any> = {};
  const docRefs: string[] = [];
  
  for (let row = 0; row < numRows; row++) {
    const doc: Record<string, any> = {};
    
    for (let col = 0; col < numColumns; col++) {
      const paramIndex = row * numColumns + col;
      const colName = columns[col];
      // Map 'id' to '_id' for DQL compatibility
      const fieldName = colName === 'id' ? '_id' : colName;
      doc[fieldName] = params[paramIndex];
    }
    
    const docName = numRows === 1 ? 'doc' : `doc${row + 1}`;
    args[docName] = doc;
    docRefs.push(`(:${docName})`);
  }
  
  const dql = `INSERT INTO ${tableName} DOCUMENTS ${docRefs.join(', ')}`;
  
  return { query: dql, args };
}

/**
 * Translate UPDATE statement
 * SQL: UPDATE users SET name = ?, age = ? WHERE id = ?
 * DQL: UPDATE users SET name = :arg1, age = :arg2 WHERE _id = :arg3
 */
function translateUpdate(sql: string, params: any[]): DQLQuery {
  let dql = sql;
  const args: Record<string, any> = {};
  
  // Replace ? placeholders with named parameters
  let paramIndex = 0;
  dql = dql.replace(/\?/g, () => {
    const paramName = `arg${paramIndex + 1}`;
    args[paramName] = params[paramIndex];
    paramIndex++;
    return `:${paramName}`;
  });
  
  // Remove quotes from identifiers
  dql = dql.replace(/"([^"]+)"/g, '$1');
  
  // Map 'id' to '_id' for DQL compatibility
  dql = dql.replace(/\bid\b/gi, '_id');
  
  return { query: dql, args: Object.keys(args).length > 0 ? args : undefined };
}

/**
 * Translate DELETE statement
 * SQL: DELETE FROM users WHERE id = ?
 * DQL: DELETE FROM users WHERE _id = :arg1
 */
function translateDelete(sql: string, params: any[]): DQLQuery {
  let dql = sql;
  const args: Record<string, any> = {};
  
  // Replace ? placeholders with named parameters
  let paramIndex = 0;
  dql = dql.replace(/\?/g, () => {
    const paramName = `arg${paramIndex + 1}`;
    args[paramName] = params[paramIndex];
    paramIndex++;
    return `:${paramName}`;
  });
  
  // Remove quotes from identifiers
  dql = dql.replace(/"([^"]+)"/g, '$1');
  
  // Map 'id' to '_id' for DQL compatibility
  dql = dql.replace(/\bid\b/gi, '_id');
  
  return { query: dql, args: Object.keys(args).length > 0 ? args : undefined };
}

/**
 * Convert DQL result items to match Drizzle's expected format
 */
export function mapDqlResultToSql(result: any): any {
  if (!result || typeof result !== 'object') {
    return result;
  }
  
  // Map '_id' back to 'id' for Drizzle compatibility
  if ('_id' in result) {
    const mapped = { ...result };
    mapped.id = mapped._id;
    delete mapped._id;
    return mapped;
  }
  
  return result;
}